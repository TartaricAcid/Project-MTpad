*建议用纸和笔模拟下建树和删节点的过程

顺藤摸瓜找儿子 ―― 一个多叉树转二叉树算法

嘛，这里我就讲讲我这个自动补全是怎么实现的
这其实就是一个多叉树转二叉树的算法
将所有兄弟连成一条线，前面一个儿子带一个标签，存储后面一个兄弟的位置
然后把第一个儿子的位置作为爸爸的一个标签
于是这个树就建好了

那么只需要用父亲的这个标签找到第一个儿子，然后根据儿子带的标签顺藤摸瓜找下去
在这里，强烈建议在数据结构中开一个标签，用来存储其前面一个兄弟的位置，具体作用后面再说
整个树就可以被遍历一遍

那么为什么要这样做呢？
你不嫌慢啊。说的好像可变数组不耗时间和内存一样，加1次操作(爸爸找第一个儿子)就可以在常数上做到极大的优化，不干白不干！

那么怎么建树呢？
很简单，下面是一个举例：
假设有一个数组，里面存储着 0 1 2 3 4 5 这六个家伙，123是0的儿子，45是3的儿子
那么建造顺序就是这样的
将1作为0的直接儿子
将2作为0的直接儿子，将1作为2的下一个兄弟
将3作为0的直接儿子，将2作为3的下一个兄弟
将4作为3的直接儿子
将5作为4的直接儿子，将4作为5的下一个兄弟
这个树就建完了。

于是这个树在这个程序的所有功能就搞完了，这就是整个自动补全的奥秘，存储一个树，不断地通过当前爸爸找特定儿子，再将儿子设置为下一个爸爸
就可以达到多段自动补全的效果。

*接下来是无关于此程序的内容，但是可能在别的程序中有用处=w=要看也可以看看
那么我们要怎么删除当中的一个儿子呢？比如删掉5什么的。
那么就要从第一个儿子开始找，找到目标儿子的前一个兄弟的位置之后把儿子前后的两个兄弟之间的联系砍断，再将两个兄弟连在一起
如果这个儿子有儿子怎么办？当然不用管啦！爸爸没了还要儿子干什么？

但是顺藤摸瓜找儿子好像有些复杂......这就是我为什么要存储前面一个兄弟的原因！
只需要知道这个儿子的位置就可以直接知道它前后两个兄弟的位置，直接将时间复杂度降为1！
